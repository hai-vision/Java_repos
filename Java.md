### Java

#### 1. Java的数据类型

>##### 1. 基本数据类型
>
>>数值型：short、int、long、float、double
>
>>字符型：char
>
>>布尔型：boolean
>
>
>
>##### 2. 引用数据类型
>
>>类（class）
>
>>接口（interface）
>
>>数组（[ ]）



#### 2. String与基本数据类型的转换

>1. 基本数据类型 --> String 
>
>  ``` java
>  int n1 = 10;
>  float n2 = 1.1F;
>  double n3 = 4.5;
>  boolean n4 = true;
>
>  // 转换方式：+ ""
>  String str1 = n1 + "";
>  String str2 = n2 + "";
>  String str3 = n3 + "";
>  String str4 = n4 + "";
>  ```
>
>2. String --> 基本数据类型
>
>  ```java
>  String str5 = "123";
>  System.out.println(Integer.parseInt(str5));
>  System.out.println(Double.parseDouble(str5));
>  ```
>
>3. String 转成 char
>
>  实际上是将String中取出第一个字符
>
>  >```java
>  >String str6 = "Eason";
>  >char ch = str6.charAt(0);
>  >```
>
>

#### 3. 变量名的命名规范

>1. 大驼峰（类名或接口名）：单词首字母大写（多个单词构成的变量名）
>2. 小驼峰（变量名）：单词首字母小写（多个单词时，首字母小写，其他单词首字母大写）
>3. 常量名：所有字母大写，多个单词组成的变量名之间用 “_” 连接
>
>



#### 4. 数组

>1. 数组的动态初始化
>
>```java
>// 1. 声明后创建
>int[] nums = new int[5];
>
>// 2. 先声明，后创建
>int[] nums;
>nums = new int[5];
>```
>
>2. 数组的静态初始化
>
>```java
>int[] nums = {1,2,3,4,5,6,7,8,9};
>```
>
>3. 数组创建后，如果没有赋值，有默认值
>
>



#### 5. 面向对象（初级）

>1. **可变参数**
>
>```java
>public int mythods(int... nums){
>      int res = 0;
>      for(int i = 0; i < nums.length; i++){
>          res += nums[i];
>      }
>
>      return res;
>}
>```
>
>>1.1 int... 表示可变参数，类型是 int 型，参数的个数可以是**0-多个**
>
>>**1.2 nums可以当做数组使用**
>
>>1.3 可变参数的实参可以为数组
>
>>1.4 可变参数的本质就是数组
>
>>**1.5 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后**
>
>>**1.6 一个形参列表中只能出现一个可变参数**
>
>
>
>2. **作用域**
>
>>2.1 在 Java 编程中，主要的变量就是成员变量（属性）和局部变量
>
>>2.2 局部变量一般是指在成员方法中定义的变量
>
>>2.3 **作用域的分类**
>
>>全局变量：也就是属性（成员变量）
>
>>局部变量：除属性以外的其他变量，作用域为定义它的代码块中
>
>>**全局变量可以不用赋值，直接使用（因为有默认值），局部变量必须赋值后使用**
>
>>**2.4 注意事项**
>
>>>1. 成员变量和局部变量可以重名，访问时遵循就近原则
>>>2. 在同一作用域中，两个局部变量不能重名
>>>3. 成员变量的生命周期长，伴随着对象的创建而创建，伴随对象的死亡而死亡。局部变量生命周期短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法的调用过程。
>
>>2.5 作用域范围不同
>
>>>全局变量（成员变量）：可以被本类使用，也可以被其他类使用（通过对象调用）
>
>>>局部变量：只能在本类中对应的方法中使用
>
>>2.6 修饰符不同
>
>>>全局变量（成员变量）可以添加修饰符
>
>>>局部变量不可以添加修饰符
>
>
>
>3. 构造方法/构造器
>
>>```java
>>class Person{
>>    String name;
>>    int age;
>>
>>	// 构造器
>>    public Person(String pName, int pAge){
>>        name = pName;
>>        age = pAge;
>>        
>>    }
>>}
>>
>>public Main{
>>	public static void main(String[] args){
>>
>>        Person person = new Person("ball", 22);
>>    }
>>}
>
>
>
>>3.1 基本介绍
>
>>```txt
>>构造方法又叫构造器，是类的一种特殊方法，它的主要作用是完成对新对象的初始化
>>```
>
>>3.2 构造器的特点
>
>>>1. **方法名和类型相同**
>>>2. 没有返回值
>>>3. 在创建对象时，系统会自动的调用该类的构造器完成 对象的初始化
>
>>3.3 使用细节和注意事项
>
>>>1. 一个类中可以定义多个不同的构造器，即构造器重载
>>>2. 构造器是完成对象的初始化，并不是创建对象
>
>>>3. 如果没有定义构造器，系统就会自动给类分配一个默认无参构造器， 比如Person(){}
>>>4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能使用默认构造器 
>
>4. **this关键字**
>
>>```txt
>>简单理解：谁调用，this就指向谁
>>```
>
>>4.1 使用细节和注意事项
>
>>>1. this 关键字可以用来访问本类的属性、方法和构造器
>>>2. this 用于区别当前类的属性和局部变量
>>>3. 访问成员方法的语法：this.方法名(参数列表)
>>>4. **访问构造器的语法：this(参数列表); [只能在构造器中使用，即只能在构造器中访问另外一个构造器]**
>>>
>>>```java
>>>public class T{
>>>    
>>>    String name;
>>>    int age;
>>>    
>>>    public T(){
>>>        // 如果调用构造器，this(参数列表)，必须放在第一条语句
>>>        this("jack", 21);
>>>    }
>>>    
>>>    public T(String name, int age){
>>>        this.name = name;
>>>        this.age = age;
>>>    }
>>>}
>>>```
>>>
>>>
>>>
>>>5. this 不能在类定义的外部使用，只能在类定义的方法中使用
>



#### 6. 面向对象（中级）

>1. **包**
>
>>包的本质
>>
>>* 实际上就是创建不同的文件夹/目录用来存放类文件
>>
>>包的作用
>>
>>* 区分相同名字的类
>>* 当类很多的时候，可以很好的管理类
>>* 控制访问范围
>
>
>
>2. **访问修饰符**
>
>>* 公开级别：用public修饰，对外公开
>>* 受保护级别：用protected修饰，对子类和同一个包中的类公开
>>* 默认级别：没有修饰符号，向同一个包中的类公开
>>* 私有级别，用private修饰，只有类本身可以访问，不对外公开
>>
>>|      | 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
>>| ---- | -------- | -------------- | ---- | ---- | ---- | ------ |
>>| 1    | 公开     | public         | √    | √    | √    | √      |
>>| 2    | 受保护   | protected      | √    | √    | √    | ×      |
>>| 3    | 默认     | 没有修饰符     | √    | √    | ×    | ×      |
>>| 4    | 私有     | private        | √    | ×    | ×    | ×      |
>>
>>**注意事项**
>>
>>>* 修饰符可以用来修饰类中的属性，成员方法以及类
>>>* 只有默认的和public才能修饰类！并且遵循上述的访问权限的特点
>>
>>3. **封装**
>>
>>>封装就是把抽象出来的**数据【属性】**和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的**操作【方法】**，才能对数据进行操作
>>>
>>>1. 封装的步骤
>>>   1. 将属性进行私有化
>>>   2. 提供一个公共的set方法，用于对属性判断并赋值
>>>   3. 提供一个公共的get方法，用于湖区属性的值
>
>4. **继承**
>
>```java
>// 语法
>// 继承可以提高代码的复用性
>class 子类名 extends 父类名{
>}
>```
>
>>1. **继承的细节**
>>   * **子类继承父类所有的属性和方法**，**但是私有属性不能在子类中直接访问，要通过公共的方法去访问**
>>   * 子类对象在创建时必须调用父类的构造器，完成父类的初始化
>>   * 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如**果父类没有提供无参构造器，则必须在子类构造器中用 super 去指定父类的哪一个构造器完成对父类的初始化工作**，否则编译不会通过
>>   * 如果希望指定调用父类的某一个构造器，则显式的调用一下
>>   * super在使用时，必须放在构造器的第一行
>>   * **super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中**
>>   * **Java所有类都是Object类的子类**
>>   * 父类构造器的调用不限于直接父类！将一直往上直到Object类
>>   * 子类最多继承一个父类（指直接继承），即Java是**单继承机制**
>>   * 不能滥用继承关系，**子类和父类之间必须满足 is a 的逻辑关系**
>>
>>2. **继承的访问机制**
>>
>>```java
>>class A{
>>    public String name = "ball";
>>    public int age = 31;    
>>    
>>}
>>
>>class B extends A{
>>    public String name = "neymar";
>>    private int age = 21;
>>}
>>
>>class C extends B{
>>    public String name = "messi";
>>}
>>```
>>
>>>**子类创建的对象在访问其属性和方法是遵循以下原则**
>>>
>>>1. 首先看子类中是否有该属性
>>>2. 如果子类有这个属性，并且可以访问，则返回该属性的信息
>>>3. 如果子类不存在这个属性，就看父类有没有这个属性，如果父类中有该属性，并且可以访问，则返回父类该属性的信息
>>>   1. 如果父类中存在该属性，但是不可以访问，则编译器会报错（即使父类的父类存在该属性）
>>>4. 如果父类没有，则按照规则 3 ，继续找上一级父类，直到Object
>
>
>
>5. **super关键字**
>
>>1. 基本介绍
>>
>>>super 代表父类的引用，用于访问父类的属性、方法、构造器
>>
>>
>>
>>2. 基本语法
>>
>>>* 可以访问父类的属性，但不能访问父类的private属性
>>>
>>>```java
>>>super.属性名;
>>>```
>>>
>>>* 访问父类的方法，不能访问父类的private方法
>>>
>>>```java
>>>super.方法名(参数列表);
>>>```
>>>
>>>* 访问父类的构造器
>>>
>>>```java
>>>super(参数列表);
>>>```
>>
>>3. **使用细节**
>>
>>>1. 调用父类构造器的好处：分工明确，**父类属性由父类初始化，子类属性由子类初始化**
>>>2. **当子类和父类的成员属性或方法重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果！**
>>>
>>>3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员
>>>
>>>   如果多个基类中都有同名的成员，使用super访问遵循就近原则。
>
>6. **this与super的比较**
>
>|      | 区别           | this                                                 | super                                    |
>| ---- | -------------- | ---------------------------------------------------- | ---------------------------------------- |
>| 1    | **访问属性**   | 访问本类中的属性，如果本类中没有，则从父类中继续查找 | 从父类中开始查找属性                     |
>| 2    | **调用方法**   | 访问本类中的方法，如果本类中没有，则从父类中继续查找 | 从父类中开始查找方法                     |
>| 3    | **调用构造器** | 调用本类中的构造器，必须放在构造器的首行             | 调用父类构造器，必须放在子类构造器的首行 |
>| 4    | **特殊**       | 表示当前对象                                         | 子类中访问父类对象                       |
>
>
>
>7. **方法的重写/覆盖（override）**
>
>>1. 基本介绍
>>
>>>**方法重写/覆盖，就是子类有一个方法，和父类（不局限于直接父类）的某个方法的名称、返回类型、参数一样**，那么我们就说子类的这个方法覆盖了父类相应的方法
>>>
>>>
>>
>>2. 注意事项和使用细节
>>
>>>* **子类方法的参数、方法名称要和父类方法的参数和方法名称完全一样**
>>>* **子类方法的返回值和父类方法的返回值类型一样，或者是父类返回值类型的子类**
>>>  * 例如：父类返回值是 Object，子类返回值类型是String
>>>* **子类方法不能缩小父类方法的访问权限**
>
>
>
>8. **方法重载和重写的比较**
>
>>|                  | 发生范围 | 方法名   | 参数列表                         | 返回类型                                                     | 修饰符                             |
>>| ---------------- | -------- | -------- | -------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
>>| 重载（overload） | 本类     | 必须相同 | 类型、个数或者顺序至少有一个不同 | 无要求                                                       | 无要求                             |
>>| 重写（override） | 父子类   | 必须相同 | 相同                             | 子类重写的方法，返回的类型和父类一致或者是父类返回类型的子类 | 子类方法不能缩小父类方法的访问范围 |
>
>9. **多态**
>
>>1. 基本介绍
>>
>>>**方法或对象具有多种形态**
>>
>>2. **多态的具体体现**
>>
>>>* 方法的多态
>>>  * 重写和重载体现多态
>>>* 对象的多态
>>>  * 一个对象的编译类型和运行类型可以不一致
>>>  * 编译类型定义对象时，就确定了，不能改变
>>>  * 运行类型是可以改变的
>>>  * 编译类型看定义时 = 号的左边，运行类型看等号的右边
>>>
>>>```java
>>>// animal编译类型是Animal，运行类型是Dog
>>>Animal animal = new Dog();
>>>
>>>// animal 的运行类型是Cat，编译类型仍然是Animal
>>>animal = new Cat();
>>>```
>>>
>>>
>>
>>3. **多态的细节和注意事项**
>>
>>>* 多态的前提是：两个对象（类）存在继承关系
>>>
>>>* 多态的向上转型
>>>
>>>  * **本质：父类的引用指向子类的对象**
>>>
>>>  * **语法：父类类型    引用名  =  new    子类类型();**
>>>
>>>  * **特点：**
>>>
>>>    * **编译类型看左边，运行类型看右边**
>>>    * **可以调用父类中的所有成员（需遵循访问权限）**
>>>    * **不能调用子类中特有成员，可以调用子类重写父类方法**
>>>      * 因为在编译阶段，能调用那些成员，是由编译器来决定的
>>>    * **最终运行效果看子类的具体实现**
>>>
>>>    
>>>
>>>* **多态的向下转型**
>>>  * 语法：子类类型    引用名  = （子类类型）**父类引用**
>>>  * 只能强转父类的引用，**不能强转父类的对象**
>>>  * 要求父类的引用必须指向的是当前目标类型的对象
>>>  * 当向下转型后，可以调用子类类型中的所有成员
>>>
>>>* **属性没有重写的说法**
>>>  * 属性的值看编译类型
>>>
>>>```java
>>>class A {
>>>    public int num = 10;
>>>    
>>>}
>>>
>>>class B extends A {
>>>    public int num = 20;
>>>}
>>>
>>>public class Test {
>>>    public static void main(String[] args) {
>>>        
>>>        // 向上转型
>>>        A a = new B();
>>>        System.out.println(a.num); // 结果为10
>>>    }
>>>}
>>>```
>>>
>>>* instanceof 比较操作符，用于判断**对象的运行类型是否为XX类型或者XX类型的子类型**
>>
>>
>>
>>4. **Java的动态绑定机制**
>>
>>>* **当调用对象方法时，该方法会和对象的内存地址/运行类型绑定**
>>>* **当调用对象属性时，没有绑定机制，哪里声明，哪里使用**



#### 7. Object类详解

>1. **equals方法**
>
>>* == 与equals的对比
>>
>>```ht
>>== 
>>1. == :既可以比较基本类型，又可以比较引用类型
>>2. == :如果判断基本类型，判断的是值是否相等
>>3. == :如果判断引用类型，判断的是地址是否相等
>>
>>equals方法
>>1. 是Object类中的方法，只能判断引用类型
>>2. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等（比如Integer、String）
>>```
>>
>>* Object类中equals方法
>>
>>```java
>>public boolean equals(Object obj) {
>>        return (this == obj);	// 判断地址是否相同
>>    }
>>```
>>
>>
>>
>>* Integer类重写Object类中的equals方法
>>
>>```java
>>public boolean equals(Object obj) {
>>        if (obj instanceof Integer) {
>>            return value == ((Integer)obj).intValue();	// 判断值是否相同
>>        }
>>        return false;
>>    }
>>```
>>
>>* String类重写Object类中的equals方法
>>
>>```java
>>public boolean equals(Object anObject) {
>>        if (this == anObject) {
>>            return true;
>>        }
>>        if (anObject instanceof String) {
>>            String anotherString = (String)anObject;
>>            int n = value.length;
>>            if (n == anotherString.value.length) {
>>                char v1[] = value;
>>                char v2[] = anotherString.value;
>>                int i = 0;
>>                while (n-- != 0) {
>>                    if (v1[i] != v2[i])
>>                        return false;
>>                    i++;
>>                }
>>                return true;
>>            }
>>        }
>>        return false;
>>    }
>>```
>>
>>
>>
>>
>>
>>
>
>
>
>>
>
>



