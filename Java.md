### Java

#### 1. Java的数据类型

>基本数据类型
>
>>数值型：short、int、long、float、double
>
>>字符型：char
>
>>布尔型：boolean
>
>
>
>引用数据类型
>
>>类（class）
>
>>接口（interface）
>
>>数组（[ ]）



#### 2. String与基本数据类型的转换

>1. 基本数据类型 --> String 
>
>  ``` java
>  int n1 = 10;
>  float n2 = 1.1F;
>  double n3 = 4.5;
>  boolean n4 = true;
>
>  // 转换方式：+ ""
>  String str1 = n1 + "";
>  String str2 = n2 + "";
>  String str3 = n3 + "";
>  String str4 = n4 + "";
>  ```
>
>2. String --> 基本数据类型
>
>  ```java
>  String str5 = "123";
>  System.out.println(Integer.parseInt(str5));
>  System.out.println(Double.parseDouble(str5));
>  ```
>
>3. String 转成 char
>
>  实际上是将String中取出第一个字符
>
>  >```java
>  >String str6 = "Eason";
>  >char ch = str6.charAt(0);
>  >```
>
>

#### 3. 变量名的命名规范

>1. 大驼峰（类名或接口名）：单词首字母大写（多个单词构成的变量名）
>2. 小驼峰（变量名）：单词首字母小写（多个单词时，首字母小写，其他单词首字母大写）
>3. 常量名：所有字母大写，多个单词组成的变量名之间用 “_” 连接
>
>



#### 4. 数组

>1. 数组的动态初始化
>
>```java
>// 1. 声明后创建
>int[] nums = new int[5];
>
>// 2. 先声明，后创建
>int[] nums;
>nums = new int[5];
>```
>
>2. 数组的静态初始化
>
>```java
>int[] nums = {1,2,3,4,5,6,7,8,9};
>```
>
>3. 数组创建后，如果没有赋值，有默认值
>
>



#### 5. 面向对象（初级）

>1. **可变参数**
>
>```java
>public int mythods(int... nums){
>      int res = 0;
>      for(int i = 0; i < nums.length; i++){
>          res += nums[i];
>      }
>
>      return res;
>}
>```
>
>>1.1 int... 表示可变参数，类型是 int 型，参数的个数可以是**0-多个**
>
>>**1.2 nums可以当做数组使用**
>
>>1.3 可变参数的实参可以为数组
>
>>1.4 可变参数的本质就是数组
>
>>**1.5 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后**
>
>>**1.6 一个形参列表中只能出现一个可变参数**
>
>
>
>2. **作用域**
>
>>2.1 在 Java 编程中，主要的变量就是成员变量（属性）和局部变量
>
>>2.2 局部变量一般是指在成员方法中定义的变量
>
>>2.3 **作用域的分类**
>
>>全局变量：也就是属性（成员变量）
>
>>局部变量：除属性以外的其他变量，作用域为定义它的代码块中
>
>>**全局变量可以不用赋值，直接使用（因为有默认值），局部变量必须赋值后使用**
>
>>**2.4 注意事项**
>
>>>1. 成员变量和局部变量可以重名，访问时遵循就近原则
>>>2. 在同一作用域中，两个局部变量不能重名
>>>3. 成员变量的生命周期长，伴随着对象的创建而创建，伴随对象的死亡而死亡。局部变量生命周期短，伴随着它的代码块的执行而创建，伴随着代码块的结束而死亡。即在一次方法的调用过程。
>
>>2.5 作用域范围不同
>
>>>全局变量（成员变量）：可以被本类使用，也可以被其他类使用（通过对象调用）
>
>>>局部变量：只能在本类中对应的方法中使用
>
>>2.6 修饰符不同
>
>>>全局变量（成员变量）可以添加修饰符
>
>>>局部变量不可以添加修饰符
>
>
>
>3. 构造方法/构造器
>
>>```java
>>class Person{
>>    String name;
>>    int age;
>>
>>	// 构造器
>>    public Person(String pName, int pAge){
>>        name = pName;
>>        age = pAge;
>>        
>>    }
>>}
>>
>>public Main{
>>	public static void main(String[] args){
>>
>>        Person person = new Person("ball", 22);
>>    }
>>}
>
>
>
>>3.1 基本介绍
>
>>```txt
>>构造方法又叫构造器，是类的一种特殊方法，它的主要作用是完成对新对象的初始化
>>```
>
>>3.2 构造器的特点
>
>>>1. **方法名和类型相同**
>>>2. 没有返回值
>>>3. 在创建对象时，系统会自动的调用该类的构造器完成 对象的初始化
>
>>3.3 使用细节和注意事项
>
>>>1. 一个类中可以定义多个不同的构造器，即构造器重载
>>>2. 构造器是完成对象的初始化，并不是创建对象
>
>>>3. 如果没有定义构造器，系统就会自动给类分配一个默认无参构造器， 比如Person(){}
>>>4. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能使用默认构造器 
>
>4. **this关键字**
>
>>```txt
>>简单理解：谁调用，this就指向谁
>>```
>
>>4.1 使用细节和注意事项
>
>>>1. this 关键字可以用来访问本类的属性、方法和构造器
>>>2. this 用于区别当前类的属性和局部变量
>>>3. 访问成员方法的语法：this.方法名(参数列表)
>>>4. **访问构造器的语法：this(参数列表); [只能在构造器中使用，即只能在构造器中访问另外一个构造器]**
>>>
>>>```java
>>>public class T{
>>>    
>>>    String name;
>>>    int age;
>>>    
>>>    public T(){
>>>        // 如果调用构造器，this(参数列表)，必须放在第一条语句
>>>        this("jack", 21);
>>>    }
>>>    
>>>    public T(String name, int age){
>>>        this.name = name;
>>>        this.age = age;
>>>    }
>>>}
>>>```
>>>
>>>
>>>
>>>5. this 不能在类定义的外部使用，只能在类定义的方法中使用
>



#### 6. 面向对象（中级）

>1. **包**
>
>>包的本质
>>
>>* 实际上就是创建不同的文件夹/目录用来存放类文件
>>
>>包的作用
>>
>>* 区分相同名字的类
>>* 当类很多的时候，可以很好的管理类
>>* 控制访问范围
>
>
>
>2. **访问修饰符**
>
>>* 公开级别：用public修饰，对外公开
>>* 受保护级别：用protected修饰，对子类和同一个包中的类公开
>>* 默认级别：没有修饰符号，向同一个包中的类公开
>>* 私有级别，用private修饰，只有类本身可以访问，不对外公开
>>
>>|      | 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
>>| ---- | -------- | -------------- | ---- | ---- | ---- | ------ |
>>| 1    | 公开     | public         | √    | √    | √    | √      |
>>| 2    | 受保护   | protected      | √    | √    | √    | ×      |
>>| 3    | 默认     | 没有修饰符     | √    | √    | ×    | ×      |
>>| 4    | 私有     | private        | √    | ×    | ×    | ×      |
>>
>>**注意事项**
>>
>>>* 修饰符可以用来修饰类中的属性，成员方法以及类
>>>* 只有默认的和public才能修饰类！并且遵循上述的访问权限的特点
>>
>>3. **封装**
>>
>>>封装就是把抽象出来的**数据【属性】**和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的**操作【方法】**，才能对数据进行操作
>>>
>>>1. 封装的步骤
>>>   1. 将属性进行私有化
>>>   2. 提供一个公共的set方法，用于对属性判断并赋值
>>>   3. 提供一个公共的get方法，用于湖区属性的值
>
>4. **继承**
>
>```java
>// 语法
>// 继承可以提高代码的复用性
>class 子类名 extends 父类名{
>}
>```
>
>>1. **继承的细节**
>>   * **子类继承父类所有的属性和方法**，**但是私有属性不能在子类中直接访问，要通过公共的方法去访问**
>>   * 子类对象在创建时必须调用父类的构造器，完成父类的初始化
>>   * 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如**果父类没有提供无参构造器，则必须在子类构造器中用 super 去指定父类的哪一个构造器完成对父类的初始化工作**，否则编译不会通过
>>   * 如果希望指定调用父类的某一个构造器，则显式的调用一下
>>   * super在使用时，必须放在构造器的第一行
>>   * **super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器中**
>>   * **Java所有类都是Object类的子类**
>>   * 父类构造器的调用不限于直接父类！将一直往上直到Object类
>>   * 子类最多继承一个父类（指直接继承），即Java是**单继承机制**
>>   * 不能滥用继承关系，**子类和父类之间必须满足 is a 的逻辑关系**
>>
>>2. **继承的访问机制**
>>
>>```java
>>class A{
>>    public String name = "ball";
>>    public int age = 31;    
>>    
>>}
>>
>>class B extends A{
>>    public String name = "neymar";
>>    private int age = 21;
>>}
>>
>>class C extends B{
>>    public String name = "messi";
>>}
>>```
>>
>>>**子类创建的对象在访问其属性和方法是遵循以下原则**
>>>
>>>1. 首先看子类中是否有该属性
>>>2. 如果子类有这个属性，并且可以访问，则返回该属性的信息
>>>3. 如果子类不存在这个属性，就看父类有没有这个属性，如果父类中有该属性，并且可以访问，则返回父类该属性的信息
>>>   1. 如果父类中存在该属性，但是不可以访问，则编译器会报错（即使父类的父类存在该属性）
>>>4. 如果父类没有，则按照规则 3 ，继续找上一级父类，直到Object
>
>
>
>5. **super关键字**
>
>>1. 基本介绍
>>
>>>super 代表父类的引用，用于访问父类的属性、方法、构造器
>>
>>
>>
>>2. 基本语法
>>
>>>* 可以访问父类的属性，但不能访问父类的private属性
>>>
>>>```java
>>>super.属性名;
>>>```
>>>
>>>* 访问父类的方法，不能访问父类的private方法
>>>
>>>```java
>>>super.方法名(参数列表);
>>>```
>>>
>>>* 访问父类的构造器
>>>
>>>```java
>>>super(参数列表);
>>>```
>>>
>>>
>>>
>>>
>>
>>

